'use strict';

function computeLeaders(ir) {
  const leaders = new Set([0]);
  ir.forEach((ins, ip) => {
    if (ins.op === 'GOTO' || ins.op === 'GOSUB') {
      if (typeof ins.target === 'number') leaders.add(ins.target);
      leaders.add(ip + 1);
    } else if (ins.op === 'NEXT') {
      if (typeof ins.forIp === 'number') leaders.add(ins.forIp);
      leaders.add(ip + 1);
    } else if (ins.op === 'LABEL' || ins.op === 'FOR' || ins.op === 'END' || ins.op === 'RETURN') {
      leaders.add(ip + 1);
      if (ins.op === 'FOR') leaders.add(ip); // entry to loop body is next ip
    }
  });
  // Clip to range
  const max = ir.length;
  const arr = Array.from(leaders).filter(n => n >= 0 && n < max).sort((a,b)=>a-b);
  return arr;
}

function leaderIndexMap(leaders) {
  const map = new Map();
  leaders.forEach((val, idx) => map.set(val, idx));
  return map;
}

function generateJS(ir) {
  const leaders = computeLeaders(ir);
  const leaderIdx = leaderIndexMap(leaders);
  // Map ip to the leader that contains it
  const ipToLeader = new Array(ir.length);
  for (let i = 0; i < leaders.length; i++) {
    const start = leaders[i];
    const end = (i + 1 < leaders.length) ? leaders[i + 1] : ir.length;
    for (let ip = start; ip < end; ip++) ipToLeader[ip] = leaders[i];
  }

  const lines = [];
  lines.push('// Generated by amosjs');
  lines.push('function createRunner(io={print: (s)=>console.log(String(s)), input: ()=>""}) {' );
  lines.push('  const state = { ip: 0, stack: [], gosub: [], vars: Object.create(null), halted: false };');
  lines.push('  function schedule(fn){ setTimeout(fn, 0); }');
  lines.push('  function tick(){ if(state.halted) return; switch(state.ip){');

  for (let i = 0; i < leaders.length; i++) {
    const start = leaders[i];
    const end = (i + 1 < leaders.length) ? leaders[i + 1] : ir.length;
    lines.push(`    case ${start}: {`);
    let terminatedInBlock = false;
    for (let ip = start; ip < end; ip++) {
      const ins = ir[ip];
      // Emit sequential execution; branch ops break out by setting state.ip
      if (ins.op === 'REM') {
        const t = (ins.text || '').replace(/\*\//g, '*\/');
        lines.push(`      // ${t}`);
      } else if (ins.op === 'PRINT') {
        if (ins.expr) {
          const expr = emitExpr(ins.expr);
          lines.push(`      io.print(${expr});`);
        } else if (ins.exprs && ins.exprs.length) {
          for (const e of ins.exprs) {
            const expr = emitExpr(e);
            lines.push(`      io.print(${expr});`);
          }
        } else if (ins.args && ins.args.length) {
          for (const arg of ins.args) {
            lines.push(`      io.print(${JSON.stringify(String(arg))});`);
          }
        } else {
          lines.push('      io.print("");');
        }
      } else if (ins.op === 'SET') {
        const val = Number(ins.value|0);
        lines.push(`      state.vars[${JSON.stringify(ins.var)}] = ${val};`);
      } else if (ins.op === 'IF_EQ') {
        const l = typeof ins.target === 'number' ? ipToLeader[ins.target] : 0;
        lines.push(`      if ((state.vars[${JSON.stringify(ins.var)}]||0) === ${Number(ins.value|0)}) { state.ip = ${l}; break; }`);
      } else if (ins.op === 'GOTO') {
        const tgt = typeof ins.target === 'number' ? ins.target : 0;
        const l = ipToLeader[tgt];
        lines.push(`      state.ip = ${l}; break;`);
        terminatedInBlock = true; break;
      } else if (ins.op === 'GOSUB') {
        const tgt = typeof ins.target === 'number' ? ins.target : 0;
        const l = ipToLeader[tgt];
        const retLeader = ipToLeader[Math.min(ip + 1, ir.length - 1)] ?? l;
        lines.push(`      state.gosub.push(${retLeader}); state.ip = ${l}; break;`);
        terminatedInBlock = true; break;
      } else if (ins.op === 'RETURN') {
        lines.push(`      const ret = state.gosub.pop(); if (ret==null){ state.halted=true; break; } state.ip = ret; break;`);
        terminatedInBlock = true; break;
      } else if (ins.op === 'END') {
        lines.push('      state.halted = true; break;');
        terminatedInBlock = true; break;
      } else if (ins.op === 'FOR') {
        // initialize var and push frame
        const from = Number(ins.from|0);
        const to = Number(ins.to|0);
        const step = Number(ins.step|0) || 1;
        lines.push(`      state.vars[${JSON.stringify(ins.var)}] = ${from};`);
        lines.push(`      state.stack.push({type:'FOR', name:${JSON.stringify(ins.var)}, to:${to}, step:${step}, loop:${ipToLeader[ip+1]||start}});`);
      } else if (ins.op === 'NEXT') {
        // increment and loop back if not finished
        lines.push(`      {`);
        lines.push(`        let i = state.stack.length-1;`);
        lines.push(`        for(; i>=0; i--){ const f=state.stack[i]; if(f.type==='FOR'${ins.var?` && f.name===${JSON.stringify(ins.var)}`:''}){ break; } }`);
        lines.push(`        if (i>=0){ const f=state.stack[i]; const name=f.name; const step=f.step; state.vars[name] = (state.vars[name]||0) + step; if ((step>=0 && state.vars[name] <= f.to) || (step<0 && state.vars[name] >= f.to)) { state.ip = f.loop; break; } else { state.stack.splice(i,1); } }`);
        lines.push(`      }`);
      }
      // no blank lines between statements
    }
    // If we didnâ€™t branch/return/halt above, set ip to next leader and break
    if (!terminatedInBlock) {
      if (i + 1 < leaders.length) {
        lines.push(`      state.ip = ${leaders[i+1]}; break;`);
      } else {
        lines.push('      state.halted = true; break;');
      }
    }
    lines.push('    }');
  }

  lines.push('    default: state.halted=true; break;');
  lines.push('  }}');
  lines.push('  function run(){ schedule(function loop(){ if(!state.halted){ tick(); schedule(loop);} }); }');
  lines.push('  return { run, state };');
  lines.push('}');
  // Emit minimal expression emitter inline
  function emitExpr(node){
    switch (node.type) {
      case 'num': return String(Number(node.value||0));
      case 'str': return JSON.stringify(String(node.value||''));
      case 'var': return `((state.vars[${JSON.stringify(node.name)}]??0))`;
      case 'unary':
        if (node.op === 'NOT') return `(!(${emitExpr(node.expr)}))`;
        return `(-(${emitExpr(node.expr)}))`;
      case 'binary': {
        const op = mapOp(node.op);
        return `((${emitExpr(node.left)}) ${op} (${emitExpr(node.right)}))`;
      }
      case 'call': {
        if (node.name === 'INPUT$') {
          const args = node.args && node.args.length ? node.args.map(a=>emitExpr(a)).join(', ') : '';
          return `(io.input(${args}))`;
        }
        return '0';
      }
      default: return '0';
    }
  }
  function mapOp(op){
    switch (op) {
      case '=': return '==';
      case '<>': return '!=';
      case 'AND': return '&&';
      case 'OR': return '||';
      default: return op;
    }
  }
  return lines.join('\n');
}

module.exports = { generateJS, computeLeaders };
